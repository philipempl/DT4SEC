<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">End-to-end security validation of IoT systems based on digital twins of end-devices</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Laurent</forename><surname>Maillet-Contoz</surname></persName>
							<email>laurent.maillet-contoz@st.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Diaz Nava STMicroelectronics Grenoble</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Emmanuel</forename><surname>Michel</surname></persName>
							<email>emmanuel.michel@st.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Diaz Nava STMicroelectronics Grenoble</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Paul-Emmanuel</forename><surname>Brun</surname></persName>
							<email>paul-emmanuel.brun@airbus.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Diaz Nava STMicroelectronics Grenoble</orgName>
								<address>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kevin</forename><surname>Leprêtre</surname></persName>
							<email>kevin.lepretre@airbus.com</email>
							<affiliation key="aff1">
								<orgName type="institution">Airbus CyberSecurity SAS</orgName>
								<address>
									<settlement>Elancourt</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Guillemette</forename><surname>Massot</surname></persName>
							<email>guillemette.massot@airbus.com</email>
							<affiliation key="aff1">
								<orgName type="institution">Airbus CyberSecurity SAS</orgName>
								<address>
									<settlement>Elancourt</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">End-to-end security validation of IoT systems based on digital twins of end-devices</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.2" ident="GROBID" when="2021-06-09T12:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Security</term>
					<term>IoT system</term>
					<term>IoT end-devices</term>
					<term>cost and time savings</term>
					<term>modelling</term>
					<term>simulated devices</term>
					<term>digital twin</term>
					<term>verification</term>
					<term>validation</term>
					<term>test</term>
					<term>scalability</term>
					<term>design quality</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>While the number of digital services is increasing faster and faster, those services rely more and more on IoT systems to collect data and perform data analysis, eventually using AI techniques. In this context, devices are part of the "root of trust" and need to be secured in order to ensure high quality and trusted digital services. This paper presents an approach to facilitate the integration, verification and then the functional validation of the security into devices based on modeling and simulation. This approach allows reducing the cost impact of adding security layer to physical devices.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>According to market forecasts, Internet of Things (IoT) products and services are spreading very quickly in all professional and mass-market usage scenarios in terms of revenues and volumes of devices and services. In the meantime, lots of pilots and commercial deployments are demonstrating the added value of IoT based solutions in realscale, and in all market segments, from the transportation industry to the utility sector but also in smart building, factory of the future, digital farming or healthcare applications. The use of historical and live data in big data lakes will allow performing data analysis to identify right system operation, obtain useful information for resources optimization, or detect anomalies, generating the appropriate alerts or alarms, that will allow a better decision making and consequently easily handle the high system complexity for a more efficient digitalized world. In this context, trustability of IoT data is key to ensure the Return On Investment (ROI) of IoT systems and services.</p><p>One of the main security weaknesses of the IoT systems concerns the end-devices <ref type="bibr" target="#b0">1</ref> , which lacked security in the first generation and still need improvements for the current one.</p><p>For instance, existing security schemes in the area of Low Power Wide Area Networks (LPWAN) have quickly evolved. However, the constraints of those protocols still have some limitations, especially in end-to-end security. Indeed, IoT systems are composed of many standards and protocols that have their own constraints and security layer. Ensuring end-toend security means that you can have a "mutualized" security layer, independently from the underneath protocol, that fits any protocols and devices constraints. This is one of the main goals of this paper to present low cost, software based and easy to implement solution to ensure end-to-end security including the data gathered by the end-devices.</p><p>A second challenge addressed by this paper is the validation of an IoT system and more particularly the device domain. The current IoT system deployment is practically done by the integration of the different sub-system components validated individually. This method is highly time consuming and not efficient concerning for instance power consumption and reach, key parameters of end-devices where high autonomy is mandatory. In order to solve this issue, this paper proposes a design methodology and tools in order to model an IoT system at high abstraction level till its physical implementation. The main goal of this proposal is to reduce development and deployment times and increase the embedded software quality running in the end-device.</p><p>The proposed methodology has been applied to test and validate the application security layer, which is generally expensive in cost and time. Indeed, devices and protocols heterogeneity makes it complex to test integration of security layer on each type of configuration. Therefore, using digital twins of devices allows quick integration, tests and validation of the security layers.</p><p>The article is organized as follows: Section II presents the IoT end-to-end security solution proposed, complementing LoRa security scheme. Section III describes the modeling approach proposed for hardware-software co-verification of end-devices. Section IV presents the use of this methodology in the implementation of the security layer, deployed in the "Critical Water Management" use case of the H2020/BRAIN-IoT project and confirmed in the "Big wine optimization" use case of the H2020/IOF2020 project. Finally, Section V concludes this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. IOT END-TO-END SECURITY</head><p>As explained in the introduction, there are a lot of different use cases based on IoT. This leads to the emergence of many different IoT protocols and standards. Moreover, IoT systems architecture is composed of intermediary components located between devices and end applications that could play different roles from messages routing, data aggregation to edge analytics. In this context, to ensure secure-by-design systems, two key principles must be guaranteed for data from the device to the final application that handles them, which are authentication and confidentiality.</p><p>Those principles must be ensured without the need to trust intermediary third-party systems (such as network provider services, data broker services…) to limit the impact of third party systems' attacks. This defense in depth concept of end-toend security is already widely used in IT systems, using for example protocols such as TLS (defined in the RFC8446) on the top of network security protocols.</p><p>IoT systems are based on a lot of heterogeneous and constrained protocols which make more complicated the application of IT end-to-end security principle. As an example, radio protocols such as IEEE standard 802.15.4 are widely used in the context of building management. On the top of this protocol, the Constrained Application Protocol (CoAP), defined in the RFC 7252 <ref type="bibr" target="#b0">[1]</ref> ensures communication capabilities between constrained devices. On the top of it, DTLS security layer (including server endpoint integration) ensures encryption and authentication capabilities. DTLS can also be enhanced by the use of EDHOC (IETF). However, this state-of-the-art end-to-end security layer is built on the top of UDP and TCP transport protocol, and can not ensure end-toend security in case of heterogeneous protocols in the dataflow (e.g: HTTP  MQTT).</p><p>During the last 10 years, new protocols used in IoT systems and not based on UDP/IP, such as LoRaWAN and SigFox, implement their own security layer fitting their constraints.</p><p>This heterogeneity of security layers leads to some limitations regarding overall IoT systems security:</p><p>-Security based on "hop-by-hop": this leads to systems based on "middlebox" that needs to be highly trusted, which implies limited trust in the overall system (as explained in the section 6.1.2.5 of LoRaWAN v1.1 specification <ref type="bibr" target="#b1">[2]</ref>: "Network servers are considered as trusted, but applications wishing to implements end-toend confidentiality and integrity MAY use additional end-to-end security solution, …"). -Security management cost: management of heterogeneous devices is expensive, e.g. regarding the security keys management, or access management. While LoRaWAN security can be strengthened by complementary security measures, the objective of the described approach is to ensure security beyond LoRaWAN.</p><p>To overcome these limitations, IETF has proposed the new SCHC (Static Context Header Compression) scheme in order to build and transport UDP/CoAP packets over LPWAN protocols. However, as stated in different case studies <ref type="bibr" target="#b2">[3]</ref>, this scheme has a strong impact on:</p><p>-Latency.</p><p>-Bandwidth overhead.</p><p>-Device resources and autonomy.</p><p>To deal with that a new applicative security layer was defined and optimized for the LPWAN, compatible with protocols such as CoAP, and MQTT in order to perform endto-end security and to ensure data trustability (patent WO2019115463A1 <ref type="bibr">[4]</ref>). While this layer is patented for now, no equivalent exists today able to provide end-to-end security over a heterogeneous dataflow. This applicative security layer ensures the end-to-end authentication and encryption of data from devices to applications, over third party components, independently from the applicative and transport protocols used in the dataflow. For example data will stay encrypted and authenticated beyond LoRaWAN and through any intermediary components such as HTTP API, MQTT brokers…</p><p>The applicative security layer is composed of: -A security module, integrated in the device, to secure by encrypting any data transmitted to the network. -An applicative security gateway (or SDK), integrated with the application, to check IoT data authenticity and decrypt its value. It is studied to have a limited impact on: -Device battery: estimated at 0,25% with the assumption of 30 messages / hour. -Network bandwidth: 10 bytes of bandwidth overhead.</p><p>-Microcontroller execution time: execution for message sending is 25% longer. Those tests have been performed on a STMicroelectronics hardware device (F091RC nucleo module with I-NUCLEO-LRWAN1 connectivity module).</p><p>The approach of this security layer manages also enrolment of devices deployed over LPWAN networks and ensures unique cryptographic key generation based on device identity, combined with stream authenticated encryption algorithms. Cryptographic material can be renewed based on local timestamp information <ref type="bibr">[4]</ref>.</p><p>Validation and testing of such a security layer are complex. Indeed, security has an impact in term of battery life, latency and bandwidth, and may interact with different hardware modules. Therefore, as it targets many kinds of devices and protocols, the validation phase should implement tests on many kinds of representative hardware considering various connectivity capabilities and hardware extensions (execution trusted zone, Trusted Platform Module…).</p><p>To reduce the testing and validation effort, a modeling approach brings a significant added value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. MODELING APPROACH FOR HARDWARE/SOFTWARE CO-</head><p>VERIFICATION OF IOT END-DEVICES The major concepts introduced by Internet of Things (IoT) systems are: 1) The interaction with the environment through sensors and actuators connected to the system and mainly 2) Data analysis performed on the huge amount of data gathered by the end-devices. 3) Decision making and system control thanks to the results obtained from the data analysis. Considering that the end-devices are fundamental components of an IoT system, this section focuses on a methodology to ensure their associated embedded software quality, their good performances, e.g. power consumption, closely related to the right behavioral implementation, and the tools proposed to facilitate, accelerate and tune such embedded software.</p><p>The debug and validation of the embedded software running in an end-device are complex and time-consuming tasks. It requires a comprehensive knowledge of the sensors, a detailed understanding of the way to recover the data to be processed through dedicated protocols according to the application needs and the way to control the transmission to communicate with the upper layer (gateway…) as well as the security aspects to ensure the data integrity.</p><p>Furthermore, the energy autonomy of any IoT end-device is critical, as most of them are battery-powered. It is therefore crucial to validate as early as possible the implementation of the dynamic power management strategies and prevent an early discontinuation of the device operations due to an erroneous energy management. This should also include a good knowledge of the overall system behavior. For instance, an end-device could spend all its battery trying to connect to the system unsuccessfully because its associated gateway or the network server is out of service.</p><p>Once the unit behavior of an end-device is presumably correct, its integration in the system is still a challenge. Its interactions must be validated in the global system, as well as its performances (quality of service, availability…).</p><p>The validation of a real size system (considering tens, hundreds or thousands of end-devices) is time consuming as well to achieve, as it requires to setup complex hardware configurations that do not scale well at the lab level and are not guaranteed to be bug-free.</p><p>The concept of digital twin <ref type="bibr" target="#b3">[5]</ref> has evolved during the last decades and is covering now a comprehensive set of possible capabilities, that still require to be standardized <ref type="bibr" target="#b4">[6]</ref>. However, to our knowledge, there are no models widely available today to verify the operation of an IoT end-device before its physical implementation and serving the needs of all the system stakeholders. To improve this situation, we advocate the adoption of a refinement approach, based on a top-down model-based design methodology. It is composed of black box (BB) and white box (WB) models at each abstraction level, called virtual twins, and described below. They are functionally equivalent to the physical device and can be used to serve different purposes. One model can be seamlessly replaced by the other, as they all share the same functional specification that represents faithfully the end-device at its boundaries. They feature the functional and extra-functional properties of the end-device (behavior, security, energy efficiency, reach…).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Typical IoT device architecture and operation</head><p>A typical architecture of an IoT end-device is composed of a microcontroller (MCU), one or several connectivity elements and one or several sensors or actuators (see Fig. <ref type="figure" target="#fig_1">2</ref>). A main issue is the verification of the embedded software, in charge of: 1) Data gathering from sensors.</p><p>2) Local processing (data formatting &amp; analysis, power management, payload construction, encryption…).</p><p>3) Transmission of the encrypted data or metadata using device connectivity capabilities (Bluetooth, LoRa, SigFox…) Sensors are typically exposing an I2C interface for digital data (or I/Os for analogue one), to let the microcontroller read and write into registers to gather the data from the sensor, while the connectivity IPs can be programmed through an SPI bus or through a UART connection. The Hardware Abstraction Layer (HAL) of the microcontroller provides an API to access the hardware resources from the embedded software.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Black box model</head><p>The BB model is an abstract representation of the enddevice. It is a simple service-oriented model that represents its functionality, regardless of the internal architecture that implements its behavior. It can be considered as the functional reference of the end-device. The BB model can be reused whatever the implementation choices, or even in case of replacement of the physical device by another one, as long as the functional specification and interfaces remain unchanged. It provides the functional contract; the other models or the physical device shall comply to. Executable, it is a nonambiguous, repeatable and deterministic model of the enddevice specifications and is implemented in Python in our work.</p><p>It abstracts the internal architecture of the end-device, as well as the embedded software, and takes as input a file containing the data values that would be obtained from a real sensor operating in real conditions.</p><p>The BB model provides several benefits: 1) It is available very early in the design process. 2) It is very fast (see Fig. <ref type="figure" target="#fig_2">3</ref>). 3) It can be easily distributed to all the stakeholders, as it does not disclose the internal architecture, nor triggers third-party IP models that can be subject to licensing restrictions. 4) Teams involved in the design and verification of the end-device will use it to validate their respective hardware and software developments. 3) End-users will quickly prototype their system and create large-scale mockups. They will be able to vary the </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. White box model</head><p>The second step of the refinement methodology is the creation of a WB model of the end-device representing the internal architecture of the device. This model is developed using the SystemC/TLM IEEE 1666 standard <ref type="bibr" target="#b5">[7]</ref>.</p><p>The model of the microcontroller typically includes a model of the embedded processor, such as QEMU or Instruction Set Simulators, and the models of all the peripheral blocks. This list obviously varies with each microcontroller, but usually includes the timers, the reset / clock / power controllers, the interrupt controller, and the hardware accelerators available for the part number. It also includes I/O models (UART, GPIOs, I2C or SPI controllers) that are used to interact with the other elements of the end-device.</p><p>The microcontroller is modelled to accurately represent the bus transactions initiated by the processor. All peripheral models expose register-accurate interfaces to support read/write transactions by the embedded software and implement the behavior of the block to offer a functional simulation.</p><p>The sensor model serves I2C requests issued by the microcontroller, and implements the behavior of the block, to react to the programming sequences. The environmental data injected in the BB model are reused to feed the sensor model, keeping the stimuli unchanged for validation purpose. In case a feedback loop is required to have the system working correctly, the inputs might be fed by a model of the environment that would ensure the global data consistency.</p><p>The connectivity model serves SPI or UART requests issued by the microcontroller, and implements the behavior of the block, to react to the programming sequences. In our current developments, we have decided to perform the communication as an abstraction of all the communication data path 2 by issuing HTTP requests to the network. This choice was done considering the main development goal was the integration and validation of the end-to-end data security. When detailed communication protocol information is needed, the connectivity models can be connected to an elaborated communication model including communication medium such as LoRaWAN, serving protocol-specific commands.</p><p>The microcontroller model executes the embedded software that shall run unchanged on the physical device, as a main requirement. A software debugger is connected to the microcontroller model to support interactive debug activities.</p><p>The WB model conforms to the functional contract of the end-device, as prescribed by the BB model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Benefits</head><p>The benefits of the modeling approach are the following: 1) System verification can be achieved in advance without the debug limitations inherent to physical devices: the models offer full inspection and observability capabilities for debug and analysis. On a physical device, it is very difficult to analyze why the implementation of a dynamic power management strategy fails, why the device does not respond anymore to requests when incorrectly set in deep sleep mode, as the software engineer doesn't have access to the state of the internal resources. The same holds for security features that prevent to inspect all the internal resources. The models address these issues by offering at any time full visibility on register values and interrupt status to support interactive debug activities. Users can replay multiple complex scenarios thanks to the repeatable deterministic simulations. Therefore, the debug and validation activities are more efficient; resulting into increased flexibility, code quality and user productivity.</p><p>2) The complexity of large-scale systems (from tens to thousands of end-devices) can be addressed by instantiating the appropriate number of models in the simulation platform. As it is purely a software approach providing high flexibility, there are no restrictions on the number of devices to be instantiated to the simulated system, while prototypes of physical devices cannot easily be replicated at a large scale for validation purpose or with difficulties to handle the complexity of such complex system in a short time period (some weeks).</p><p>3) The system reliability is increased, as the validation strategy of the end-device is strengthened by adding scenarios focusing on device robustness considering its interaction with system environment: the tests do not only assess the functional correctness of the device, they also stress corner cases or error situations that are difficult to reproduce and test on the physical device. When an update of the embedded software is required, the simulation platform offers an undisputed advantage to validate upfront that the update is correct and does not break the system functionality, before deployment in the field.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. IMPLEMENTATION OF THE END-TO-END SECURITY USING THE MODELING APPROACH</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Case study overview</head><p>In order to validate the proposed methodology and easily implement and validate end-to-end security in an IoT system using a modeling approach, two use cases were selected coming from two different H2020 projects:</p><p>-Critical Infrastructure of Water management system use case developed in the BRAIN-IoT project <ref type="bibr">[8][9]</ref>. -Big Wine Optimization use case in the frame of the IOF2020 project [10] <ref type="bibr" target="#b9">[11]</ref>. If these two use cases address different areas (Water Utility and Digital farming), they have common components and a close IoT architecture, which is frequently used in many deployed IoT systems. Fig. <ref type="figure">4</ref> depicts the common elements used in both architectures: End-devices (water meters, waterstations, etc.), a LoRaWAN communication system and the Middleware (SensiNact).</p><p>In this architecture, the data gathered from the sensors are encapsulated, encrypted and sent by a LoRaWAN transmitter. The Gateway recovers and sends them through internet till the LoRa Server that activates the end-devices and decrypt data transported by LoRaWAN. These data are sent to the business application through the MQTT protocol. Then, the middleware is in charge of decapsulating the useful data and storing them in a database for data analysis. Finally, the processed data are displayed in application dashboard for end-user exploitation.</p><p>LoRaWAN provides a security path hop-to-hop but it doesn't protect the data from attacks on its own network server and application server components <ref type="bibr" target="#b1">[2]</ref>. Furthermore, the MQTT used is not a secure protocol <ref type="bibr">[12]</ref>. Due to the lack of an end-to-end data security protection, it has been proposed to implement a security layer to the existing physical end-devices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Adding security to end-device digital twins 1) In the black box model</head><p>The security module is used in the BB model to encrypt the data payload to be transmitted to SensiNact through the HTTP protocol. From an implementation perspective, the security module is delivered as a compiled library providing C functions. In this work, the library is wrapped to call the encryption function from the Python BB model, using a static key as a pipe cleaner. Once the payload has been encrypted, the BB model continues its execution as when the data are not encrypted. As the encryption step is added in the data flow, it can be easily switched on or off for debug purpose. As next development task, it is planned to integrate the negotiation of the runtime key to run in an operational mode.</p><p>2) In the white box model Adding security in the WB model consists in adding in the embedded software running on the microcontroller model the calls to the functions of the C encryption library of the security module. It encrypts the payload eventually passed to the connectivity model. As for the BB model, the data are encrypted using a static key, as a pipe cleaner. Runtime key negotiation is the next step to complete. All the rest of the embedded remains unchanged. Consequently, it is very easy to support both unsecure and secure communication modes, for instance for debug purpose.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Adding security in SensiNact</head><p>The security layer decrypts and checks the integrity of data received. To perform those actions, an SDK was developed to integrate those functions in the final application. This component was designed as a stand-alone element to facilitate its integration inside more complex applications. Only the configuration must be managed by the SDK user. The configurations were initially static inputs to carry out the first tests. Ultimately, it will enable the component to be enrolled dynamically at a key server. This key server ensures the confidentiality and delivers securely symmetric keys to IoT devices through secure channel by means of runtime key exchange mechanism. The SDK acts as a local manager and controls communications between devices, application and key server.</p><p>The SDK is composed of the next four main components: -Enrolment module: In case of unknown device, this module performs self-enrolment operation and returns an encrypted AES ciphering key used by the device for future communications. -Device status check: this module checks whether the devices have been revoked, -Authentication &amp; integrity check: This module checks the message integrity and the device stateless authentication using public device identity and the corresponding secret key. -Decryption module: This module decrypts the payload and forwards the clear text message to the data processing module of the application, eventually through the database.</p><p>The SDK is located between data transmission module and data processing module of the application and works transparently for the rest of the application, see Fig. <ref type="figure">5</ref>. Each of those modules has the capability to forward abnormal events (authentication error, decryption error…) to the logging module of the application. This is essential for the purpose of monitoring IoT devices behaviors and alerting in case of errors or attacks on network and devices. The validation of the security features follows the approach described below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Validation strategy</head><p>The validation strategy adopted is based on the separation of concern concept. We focus first on the right end-device  implementation, considering the other parts as correct. The main objective of this step is to validate the global functionality of the end-device and the end-to-end data path. Therefore, the model of the end-device performs data gathering (from the input table), data encapsulation and encryption, and data transmission to the network through HTTP requests, as an abstraction of the complete LoRaWAN communication data path (gateway + LoRa server / MQTT), to reach SensiNact. From Fig. <ref type="figure">4</ref>, we use the observation point OP <ref type="bibr" target="#b0">(1)</ref> to check that the data emitted by the model are correct, OP (2) that the data are correctly received by SensiNact, and ultimately, OP (3) that the data are correctly displayed in the application dashboard, see the results shown in Fig. <ref type="figure">6 and 7</ref> coming from the simulation of the two mentioned use cases.</p><p>Following our top-down methodology starting with the higher abstraction level, the BB model is used to verify that the end-device is correctly transmitting the data to the application dashboard thought SensiNact, regardless of the internal implementation details of the device. The BB model provides the functional reference results to be compared against for the subsequent refinement steps of the design flow.</p><p>In the second step, the BB model is replaced by the WB model, to develop and validate the embedded software running on the microcontroller: performing data collection from the sensors, local computation and preparation and encryption of the payload to be transmitted by the connectivity IP.</p><p>In the third step, the WB model is replaced by the actual end-device, which runs the unchanged embedded software.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Experimental results</head><p>Fig. <ref type="figure">6 and 7</ref> show the simulation results, at system level, obtained by the processing, transmission, data recovery and display of the sensors data. Fig 6 <ref type="figure">.</ref> shows in the application dashboard, the data gathered from a water meter used in the Critical Water Management use case; whereas Fig 7 <ref type="figure">.</ref> shows the data gathered from different sensors (temperature, humidity, atmospheric pressure, wind speed, battery voltage) used in Big Wine Optimization use case. In both simulations, tabular date entries were used to provide the data coming from each sensor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. CONCLUSION</head><p>Embedded software, security implementation and validation are non-trivial, time and resource-consuming tasks, requiring a high level of expertise. The problem is very well known and is exacerbated with the deployment of IoT systems.</p><p>This paper presented a design methodology approach to relieve this problem, reduce design and validation times, increase the quality of design, ensure better performances of the overall system and finally facilitate the scale up of the number of end-devices, by using the digital twin concept.</p><p>Last but not least, this proposed model-based approach allowed the implementation, verification and validation of an end-to-end security solution in few weeks thanks to the facilities of debug and observability.</p><p>We believe that this type of approach is really required by the industry to facilitate the deployment of IoT complex and critical systems requiring a high level of trust and reliability. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig 1 :</head><label>1</label><figDesc>Fig 1: IoT dataflow with end-to-end security</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 :</head><label>2</label><figDesc>Fig. 2: Typical IoT end-device architecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 :</head><label>3</label><figDesc>Fig. 3: Simulation time for black box and white box models</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 :Fig. 5 :</head><label>45</label><figDesc>Fig. 4: IoT System architecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 7 :Fig. 6 :</head><label>76</label><figDesc>Fig. 7: Plot of weather station parameters in UC3.2 IOF 2020 project</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">End-device performs the sensing or actuating function allowing the interaction with the system environment. Others well known naming are Sensor nodes or Smart objects.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">In the LoRaWAN examples presented in Section IV, the communication data path LoRa elements (transmitter, Gateway, LoRa Server and MQTT) are abstracted by the HTTP protocol.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>This work has received funding from the European Union Horizon 2020 research and innovation programme under grant agreement No 780089, Brain-IoT project.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<ptr target="https://tools.ietf.org/html/rfc7252" />
	</analytic>
	<monogr>
		<title level="m">The Constrained Application Protocol (CoAP)</title>
				<imprint>
			<biblScope unit="volume">7252</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="https://lora-alliance.org/resource-hub" />
		<title level="m">LoRaWAN specifications</title>
				<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Impact of SCHC Compression and Fragmentation in LPWAN: A Case Study with LoRaWAN</title>
		<ptr target="https://patents.google.com/patent/WO20191" />
	</analytic>
	<monogr>
		<title level="j">Jesus Sanchez-Gomez</title>
		<imprint/>
	</monogr>
	<note>et al [4] Secure communication method, patent WO2019115463A1</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A Short Introduction to Digital Twins</title>
		<author>
			<persName><forename type="first">P</forename><surname>Van Schalkwyk</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">W</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IIC Journal of Innovation</title>
		<imprint>
			<date type="published" when="2019-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">E</forename><surname>Harper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ganz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Malakuti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Digital Twin Architecture and Standards</title>
				<imprint>
			<date type="published" when="2019-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">IEEE</title>
		<imprint>
			<biblScope unit="page" from="1666" to="2011" />
			<date type="published" when="2011" />
		</imprint>
		<respStmt>
			<orgName>IEEE Standard for Standard SystemC Language Reference Manual</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">H2020/Ria</forename><surname>Brain-Iot</surname></persName>
		</author>
		<author>
			<persName><surname>Project</surname></persName>
		</author>
		<ptr target="https://cordis.europa.eu/project/id/780089" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Brain-IOT Deliverable 6.2 -Lab-Scale Evaluations</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Diaz</forename><surname>Nava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Cantero</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019-07-09" />
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">F2020</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName><surname>H2020/Lsp</surname></persName>
		</author>
		<ptr target="https://european-iot-pilots.eu/project/iof2020-2/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Wine culture and processing optimization through light combinations of sensor networks and big data analysis</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">Diaz</forename><surname>Nava</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Dubourdieu</surname></persName>
		</author>
		<ptr target="https://www.hdigitag.fr/fr/agriculture-revue-usages-anrt-digitag-1206019/" />
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
